/*
 * Deutscher Bundestag - DIP
 * API des Dokumentations- und Informationssystems für Parlamentsmaterialien
 *
 * The version of the OpenAPI document: 1.3
 * Contact: parlamentsdokumentation@bundestag.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Aktivitaet;
import org.openapitools.client.model.AktivitaetListResponse;
import org.openapitools.client.model.GetVorgang404Response;
import org.openapitools.client.model.GetVorgangList400Response;
import org.openapitools.client.model.GetVorgangList401Response;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import org.openapitools.client.model.Zuordnung;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AktivittenApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AktivittenApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AktivittenApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getAktivitaet
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten einer Aktivität </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAktivitaetCall(Integer id, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/aktivitaet/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyHeader", "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAktivitaetValidateBeforeCall(Integer id, String format, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getAktivitaet(Async)");
        }

        return getAktivitaetCall(id, format, _callback);

    }

    /**
     * Liefert Metadaten zu einer Aktivität
     * 
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return Aktivitaet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten einer Aktivität </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public Aktivitaet getAktivitaet(Integer id, String format) throws ApiException {
        ApiResponse<Aktivitaet> localVarResp = getAktivitaetWithHttpInfo(id, format);
        return localVarResp.getData();
    }

    /**
     * Liefert Metadaten zu einer Aktivität
     * 
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return ApiResponse&lt;Aktivitaet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten einer Aktivität </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Aktivitaet> getAktivitaetWithHttpInfo(Integer id, String format) throws ApiException {
        okhttp3.Call localVarCall = getAktivitaetValidateBeforeCall(id, format, null);
        Type localVarReturnType = new TypeToken<Aktivitaet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Liefert Metadaten zu einer Aktivität (asynchronously)
     * 
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten einer Aktivität </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAktivitaetAsync(Integer id, String format, final ApiCallback<Aktivitaet> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAktivitaetValidateBeforeCall(id, format, _callback);
        Type localVarReturnType = new TypeToken<Aktivitaet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAktivitaetList
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDeskriptor Deskriptor  Selektiert alle Entitäten, die mit dem angegebenen Deskriptor verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Deskriptoren zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Deskriptoren ist mit einer einzigen Abfrage nicht möglich. Die Deskriptoren müssen dazu einzeln abgefragt werden.  (optional)
     * @param fDokumentart Drucksache oder Plenarprotokoll  Selektiert alle Entitäten, die mit der angegebenen Dokumentart verknüpft sind.  (optional)
     * @param fDokumentnummer Dokumentnummer einer Drucksache oder eines Plenarprotokolls  Selektiert alle Entitäten, die mit der angegebenen Dokumentnummer verknüpft sind. Kann wiederholt werden, um mehrere Dokumentnummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fDrucksache ID einer verknüpften Drucksache  Selektiert alle Entitäten, die mit der angegebenen Drucksache verknüpft sind.  (optional)
     * @param fDrucksachetyp Typ der Drucksache  Selektiert alle Entitäten, die mit dem angegebenen Drucksachetyp verknüpft sind.  (optional)
     * @param fFrageNummer Fragenummer/Listenziffer  Selektiert alle Entitäten, die mit der angegebenen Fragenummer in einer Drucksache verknüpft sind. Kann wiederholt werden, um mehrere Fragenummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fPlenarprotokoll ID eines verknüpften Plenarprotokolls  Selektiert alle Entitäten, die mit dem angegebenen Plenarprotokoll verknüpft sind.  (optional)
     * @param fSachgebiet Sachgebiet  Selektiert alle Entitäten, die mit dem angegebenen Sachgebiet verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Sachgebiete zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Sachgebiete ist mit einer einzigen Abfrage nicht möglich. Die Sachgebiete müssen dazu einzeln abgefragt werden.  (optional)
     * @param fUrheber Urheber  Selektiert alle Entitäten, die mit dem angegebenen Urheber in einer Drucksache verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Urheber zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Urheber ist mit einer einzigen Abfrage nicht möglich. Die Urheber müssen dazu einzeln abgefragt werden.  (optional)
     * @param fVorgangstyp Vorgangstyp  Selektiert alle Entitäten, die dem angegebenen Vorgangstyp zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fVorgangstypNotation Vorgangstyp-Notation  Selektiert alle Entitäten, die der angegebenen Vorgangstyp-Notation zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fZuordnung Zuordnung der Entität zum Bundestag, Bundesrat, Bundesversammlung oder Europakammer (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten zu Aktivitäten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAktivitaetListCall(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<String> fDeskriptor, String fDokumentart, List<String> fDokumentnummer, Integer fDrucksache, String fDrucksachetyp, List<String> fFrageNummer, List<Integer> fId, Integer fPlenarprotokoll, List<String> fSachgebiet, List<String> fUrheber, List<String> fVorgangstyp, List<Integer> fVorgangstypNotation, List<Integer> fWahlperiode, Zuordnung fZuordnung, String cursor, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/aktivitaet";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fAktualisiertStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.aktualisiert.start", fAktualisiertStart));
        }

        if (fAktualisiertEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.aktualisiert.end", fAktualisiertEnd));
        }

        if (fDatumStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.datum.start", fDatumStart));
        }

        if (fDatumEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.datum.end", fDatumEnd));
        }

        if (fDeskriptor != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.deskriptor", fDeskriptor));
        }

        if (fDokumentart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.dokumentart", fDokumentart));
        }

        if (fDokumentnummer != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.dokumentnummer", fDokumentnummer));
        }

        if (fDrucksache != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.drucksache", fDrucksache));
        }

        if (fDrucksachetyp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.drucksachetyp", fDrucksachetyp));
        }

        if (fFrageNummer != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.frage_nummer", fFrageNummer));
        }

        if (fId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.id", fId));
        }

        if (fPlenarprotokoll != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.plenarprotokoll", fPlenarprotokoll));
        }

        if (fSachgebiet != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.sachgebiet", fSachgebiet));
        }

        if (fUrheber != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.urheber", fUrheber));
        }

        if (fVorgangstyp != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.vorgangstyp", fVorgangstyp));
        }

        if (fVorgangstypNotation != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.vorgangstyp_notation", fVorgangstypNotation));
        }

        if (fWahlperiode != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.wahlperiode", fWahlperiode));
        }

        if (fZuordnung != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.zuordnung", fZuordnung));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyHeader", "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAktivitaetListValidateBeforeCall(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<String> fDeskriptor, String fDokumentart, List<String> fDokumentnummer, Integer fDrucksache, String fDrucksachetyp, List<String> fFrageNummer, List<Integer> fId, Integer fPlenarprotokoll, List<String> fSachgebiet, List<String> fUrheber, List<String> fVorgangstyp, List<Integer> fVorgangstypNotation, List<Integer> fWahlperiode, Zuordnung fZuordnung, String cursor, String format, final ApiCallback _callback) throws ApiException {
        return getAktivitaetListCall(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fDeskriptor, fDokumentart, fDokumentnummer, fDrucksache, fDrucksachetyp, fFrageNummer, fId, fPlenarprotokoll, fSachgebiet, fUrheber, fVorgangstyp, fVorgangstypNotation, fWahlperiode, fZuordnung, cursor, format, _callback);

    }

    /**
     * Liefert eine Liste von Metadaten zu Aktivitäten
     * 
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDeskriptor Deskriptor  Selektiert alle Entitäten, die mit dem angegebenen Deskriptor verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Deskriptoren zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Deskriptoren ist mit einer einzigen Abfrage nicht möglich. Die Deskriptoren müssen dazu einzeln abgefragt werden.  (optional)
     * @param fDokumentart Drucksache oder Plenarprotokoll  Selektiert alle Entitäten, die mit der angegebenen Dokumentart verknüpft sind.  (optional)
     * @param fDokumentnummer Dokumentnummer einer Drucksache oder eines Plenarprotokolls  Selektiert alle Entitäten, die mit der angegebenen Dokumentnummer verknüpft sind. Kann wiederholt werden, um mehrere Dokumentnummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fDrucksache ID einer verknüpften Drucksache  Selektiert alle Entitäten, die mit der angegebenen Drucksache verknüpft sind.  (optional)
     * @param fDrucksachetyp Typ der Drucksache  Selektiert alle Entitäten, die mit dem angegebenen Drucksachetyp verknüpft sind.  (optional)
     * @param fFrageNummer Fragenummer/Listenziffer  Selektiert alle Entitäten, die mit der angegebenen Fragenummer in einer Drucksache verknüpft sind. Kann wiederholt werden, um mehrere Fragenummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fPlenarprotokoll ID eines verknüpften Plenarprotokolls  Selektiert alle Entitäten, die mit dem angegebenen Plenarprotokoll verknüpft sind.  (optional)
     * @param fSachgebiet Sachgebiet  Selektiert alle Entitäten, die mit dem angegebenen Sachgebiet verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Sachgebiete zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Sachgebiete ist mit einer einzigen Abfrage nicht möglich. Die Sachgebiete müssen dazu einzeln abgefragt werden.  (optional)
     * @param fUrheber Urheber  Selektiert alle Entitäten, die mit dem angegebenen Urheber in einer Drucksache verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Urheber zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Urheber ist mit einer einzigen Abfrage nicht möglich. Die Urheber müssen dazu einzeln abgefragt werden.  (optional)
     * @param fVorgangstyp Vorgangstyp  Selektiert alle Entitäten, die dem angegebenen Vorgangstyp zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fVorgangstypNotation Vorgangstyp-Notation  Selektiert alle Entitäten, die der angegebenen Vorgangstyp-Notation zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fZuordnung Zuordnung der Entität zum Bundestag, Bundesrat, Bundesversammlung oder Europakammer (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return AktivitaetListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten zu Aktivitäten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public AktivitaetListResponse getAktivitaetList(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<String> fDeskriptor, String fDokumentart, List<String> fDokumentnummer, Integer fDrucksache, String fDrucksachetyp, List<String> fFrageNummer, List<Integer> fId, Integer fPlenarprotokoll, List<String> fSachgebiet, List<String> fUrheber, List<String> fVorgangstyp, List<Integer> fVorgangstypNotation, List<Integer> fWahlperiode, Zuordnung fZuordnung, String cursor, String format) throws ApiException {
        ApiResponse<AktivitaetListResponse> localVarResp = getAktivitaetListWithHttpInfo(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fDeskriptor, fDokumentart, fDokumentnummer, fDrucksache, fDrucksachetyp, fFrageNummer, fId, fPlenarprotokoll, fSachgebiet, fUrheber, fVorgangstyp, fVorgangstypNotation, fWahlperiode, fZuordnung, cursor, format);
        return localVarResp.getData();
    }

    /**
     * Liefert eine Liste von Metadaten zu Aktivitäten
     * 
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDeskriptor Deskriptor  Selektiert alle Entitäten, die mit dem angegebenen Deskriptor verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Deskriptoren zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Deskriptoren ist mit einer einzigen Abfrage nicht möglich. Die Deskriptoren müssen dazu einzeln abgefragt werden.  (optional)
     * @param fDokumentart Drucksache oder Plenarprotokoll  Selektiert alle Entitäten, die mit der angegebenen Dokumentart verknüpft sind.  (optional)
     * @param fDokumentnummer Dokumentnummer einer Drucksache oder eines Plenarprotokolls  Selektiert alle Entitäten, die mit der angegebenen Dokumentnummer verknüpft sind. Kann wiederholt werden, um mehrere Dokumentnummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fDrucksache ID einer verknüpften Drucksache  Selektiert alle Entitäten, die mit der angegebenen Drucksache verknüpft sind.  (optional)
     * @param fDrucksachetyp Typ der Drucksache  Selektiert alle Entitäten, die mit dem angegebenen Drucksachetyp verknüpft sind.  (optional)
     * @param fFrageNummer Fragenummer/Listenziffer  Selektiert alle Entitäten, die mit der angegebenen Fragenummer in einer Drucksache verknüpft sind. Kann wiederholt werden, um mehrere Fragenummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fPlenarprotokoll ID eines verknüpften Plenarprotokolls  Selektiert alle Entitäten, die mit dem angegebenen Plenarprotokoll verknüpft sind.  (optional)
     * @param fSachgebiet Sachgebiet  Selektiert alle Entitäten, die mit dem angegebenen Sachgebiet verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Sachgebiete zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Sachgebiete ist mit einer einzigen Abfrage nicht möglich. Die Sachgebiete müssen dazu einzeln abgefragt werden.  (optional)
     * @param fUrheber Urheber  Selektiert alle Entitäten, die mit dem angegebenen Urheber in einer Drucksache verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Urheber zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Urheber ist mit einer einzigen Abfrage nicht möglich. Die Urheber müssen dazu einzeln abgefragt werden.  (optional)
     * @param fVorgangstyp Vorgangstyp  Selektiert alle Entitäten, die dem angegebenen Vorgangstyp zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fVorgangstypNotation Vorgangstyp-Notation  Selektiert alle Entitäten, die der angegebenen Vorgangstyp-Notation zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fZuordnung Zuordnung der Entität zum Bundestag, Bundesrat, Bundesversammlung oder Europakammer (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return ApiResponse&lt;AktivitaetListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten zu Aktivitäten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AktivitaetListResponse> getAktivitaetListWithHttpInfo(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<String> fDeskriptor, String fDokumentart, List<String> fDokumentnummer, Integer fDrucksache, String fDrucksachetyp, List<String> fFrageNummer, List<Integer> fId, Integer fPlenarprotokoll, List<String> fSachgebiet, List<String> fUrheber, List<String> fVorgangstyp, List<Integer> fVorgangstypNotation, List<Integer> fWahlperiode, Zuordnung fZuordnung, String cursor, String format) throws ApiException {
        okhttp3.Call localVarCall = getAktivitaetListValidateBeforeCall(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fDeskriptor, fDokumentart, fDokumentnummer, fDrucksache, fDrucksachetyp, fFrageNummer, fId, fPlenarprotokoll, fSachgebiet, fUrheber, fVorgangstyp, fVorgangstypNotation, fWahlperiode, fZuordnung, cursor, format, null);
        Type localVarReturnType = new TypeToken<AktivitaetListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Liefert eine Liste von Metadaten zu Aktivitäten (asynchronously)
     * 
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDeskriptor Deskriptor  Selektiert alle Entitäten, die mit dem angegebenen Deskriptor verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Deskriptoren zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Deskriptoren ist mit einer einzigen Abfrage nicht möglich. Die Deskriptoren müssen dazu einzeln abgefragt werden.  (optional)
     * @param fDokumentart Drucksache oder Plenarprotokoll  Selektiert alle Entitäten, die mit der angegebenen Dokumentart verknüpft sind.  (optional)
     * @param fDokumentnummer Dokumentnummer einer Drucksache oder eines Plenarprotokolls  Selektiert alle Entitäten, die mit der angegebenen Dokumentnummer verknüpft sind. Kann wiederholt werden, um mehrere Dokumentnummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fDrucksache ID einer verknüpften Drucksache  Selektiert alle Entitäten, die mit der angegebenen Drucksache verknüpft sind.  (optional)
     * @param fDrucksachetyp Typ der Drucksache  Selektiert alle Entitäten, die mit dem angegebenen Drucksachetyp verknüpft sind.  (optional)
     * @param fFrageNummer Fragenummer/Listenziffer  Selektiert alle Entitäten, die mit der angegebenen Fragenummer in einer Drucksache verknüpft sind. Kann wiederholt werden, um mehrere Fragenummern zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fPlenarprotokoll ID eines verknüpften Plenarprotokolls  Selektiert alle Entitäten, die mit dem angegebenen Plenarprotokoll verknüpft sind.  (optional)
     * @param fSachgebiet Sachgebiet  Selektiert alle Entitäten, die mit dem angegebenen Sachgebiet verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Sachgebiete zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Sachgebiete ist mit einer einzigen Abfrage nicht möglich. Die Sachgebiete müssen dazu einzeln abgefragt werden.  (optional)
     * @param fUrheber Urheber  Selektiert alle Entitäten, die mit dem angegebenen Urheber in einer Drucksache verknüpft sind. Kann wiederholt werden, um die Schnittmenge mehrerer Urheber zu selektieren. Hinterlegt ist eine UND-Suche.  Eine ODER-Suche über mehrere Urheber ist mit einer einzigen Abfrage nicht möglich. Die Urheber müssen dazu einzeln abgefragt werden.  (optional)
     * @param fVorgangstyp Vorgangstyp  Selektiert alle Entitäten, die dem angegebenen Vorgangstyp zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fVorgangstypNotation Vorgangstyp-Notation  Selektiert alle Entitäten, die der angegebenen Vorgangstyp-Notation zugeordnet sind. Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param fZuordnung Zuordnung der Entität zum Bundestag, Bundesrat, Bundesversammlung oder Europakammer (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Metadaten zu Aktivitäten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAktivitaetListAsync(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<String> fDeskriptor, String fDokumentart, List<String> fDokumentnummer, Integer fDrucksache, String fDrucksachetyp, List<String> fFrageNummer, List<Integer> fId, Integer fPlenarprotokoll, List<String> fSachgebiet, List<String> fUrheber, List<String> fVorgangstyp, List<Integer> fVorgangstypNotation, List<Integer> fWahlperiode, Zuordnung fZuordnung, String cursor, String format, final ApiCallback<AktivitaetListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAktivitaetListValidateBeforeCall(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fDeskriptor, fDokumentart, fDokumentnummer, fDrucksache, fDrucksachetyp, fFrageNummer, fId, fPlenarprotokoll, fSachgebiet, fUrheber, fVorgangstyp, fVorgangstypNotation, fWahlperiode, fZuordnung, cursor, format, _callback);
        Type localVarReturnType = new TypeToken<AktivitaetListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
