/*
 * Deutscher Bundestag - DIP
 * API des Dokumentations- und Informationssystems für Parlamentsmaterialien
 *
 * The version of the OpenAPI document: 1.3
 * Contact: parlamentsdokumentation@bundestag.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Liefert das Ressort (Bundesministerium), das innerhalb der Bundesregierung federführend für die Ausarbeitung z. B. eines Gesetzentwurfs oder eines Antrags oder die Beantwortung von Anfragen ist. Wird nur verwendet, wenn Urheber einer Drucksache die Bundesregierung ist.  Das Ressort wird auch bei persönlichen Urhebern verwendet, um die Funktion von Angehörigen der Bundesregierung zu präzisieren, z. B. „Dr. Robert Habeck, Bundesmin., Bundesministerium für Wirtschaft und Klimaschutz“ oder „Dr. Florian Toncar, Parl. Staatssekr., Bundesministerium der Finanzen“. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-15T12:05:00.915435+02:00[Europe/Berlin]", comments = "Generator version: 7.12.0")
public class Ressort {
  public static final String SERIALIZED_NAME_FEDERFUEHREND = "federfuehrend";
  @SerializedName(SERIALIZED_NAME_FEDERFUEHREND)
  @javax.annotation.Nonnull
  private Boolean federfuehrend;

  public static final String SERIALIZED_NAME_TITEL = "titel";
  @SerializedName(SERIALIZED_NAME_TITEL)
  @javax.annotation.Nonnull
  private String titel;

  public Ressort() {
  }

  public Ressort federfuehrend(@javax.annotation.Nonnull Boolean federfuehrend) {
    this.federfuehrend = federfuehrend;
    return this;
  }

  /**
   * Get federfuehrend
   * @return federfuehrend
   */
  @javax.annotation.Nonnull
  public Boolean getFederfuehrend() {
    return federfuehrend;
  }

  public void setFederfuehrend(@javax.annotation.Nonnull Boolean federfuehrend) {
    this.federfuehrend = federfuehrend;
  }


  public Ressort titel(@javax.annotation.Nonnull String titel) {
    this.titel = titel;
    return this;
  }

  /**
   * Get titel
   * @return titel
   */
  @javax.annotation.Nonnull
  public String getTitel() {
    return titel;
  }

  public void setTitel(@javax.annotation.Nonnull String titel) {
    this.titel = titel;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Ressort ressort = (Ressort) o;
    return Objects.equals(this.federfuehrend, ressort.federfuehrend) &&
        Objects.equals(this.titel, ressort.titel);
  }

  @Override
  public int hashCode() {
    return Objects.hash(federfuehrend, titel);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Ressort {\n");
    sb.append("    federfuehrend: ").append(toIndentedString(federfuehrend)).append("\n");
    sb.append("    titel: ").append(toIndentedString(titel)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("federfuehrend");
    openapiFields.add("titel");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("federfuehrend");
    openapiRequiredFields.add("titel");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Ressort
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Ressort.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Ressort is not found in the empty JSON string", Ressort.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Ressort.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Ressort` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Ressort.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("titel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `titel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("titel").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Ressort.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Ressort' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Ressort> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Ressort.class));

       return (TypeAdapter<T>) new TypeAdapter<Ressort>() {
           @Override
           public void write(JsonWriter out, Ressort value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Ressort read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Ressort given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Ressort
   * @throws IOException if the JSON string is invalid with respect to Ressort
   */
  public static Ressort fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Ressort.class);
  }

  /**
   * Convert an instance of Ressort to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

