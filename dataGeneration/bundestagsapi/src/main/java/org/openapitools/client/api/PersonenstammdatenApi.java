/*
 * Deutscher Bundestag - DIP
 * API des Dokumentations- und Informationssystems für Parlamentsmaterialien
 *
 * The version of the OpenAPI document: 1.3
 * Contact: parlamentsdokumentation@bundestag.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GetVorgang404Response;
import org.openapitools.client.model.GetVorgangList400Response;
import org.openapitools.client.model.GetVorgangList401Response;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import org.openapitools.client.model.Person;
import org.openapitools.client.model.PersonListResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PersonenstammdatenApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PersonenstammdatenApi() {
        this(Configuration.getDefaultApiClient());
    }

    public PersonenstammdatenApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getPerson
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPersonCall(Integer id, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/person/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyHeader", "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPersonValidateBeforeCall(Integer id, String format, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getPerson(Async)");
        }

        return getPersonCall(id, format, _callback);

    }

    /**
     * Liefert Personenstammdaten zu einer Person
     * 
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return Person
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public Person getPerson(Integer id, String format) throws ApiException {
        ApiResponse<Person> localVarResp = getPersonWithHttpInfo(id, format);
        return localVarResp.getData();
    }

    /**
     * Liefert Personenstammdaten zu einer Person
     * 
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return ApiResponse&lt;Person&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Person> getPersonWithHttpInfo(Integer id, String format) throws ApiException {
        okhttp3.Call localVarCall = getPersonValidateBeforeCall(id, format, null);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Liefert Personenstammdaten zu einer Person (asynchronously)
     * 
     * @param id  (required)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Die angefragte Entität wurde nicht gefunden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPersonAsync(Integer id, String format, final ApiCallback<Person> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPersonValidateBeforeCall(id, format, _callback);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPersonList
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPersonListCall(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<Integer> fId, List<Integer> fWahlperiode, String cursor, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/person";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fAktualisiertStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.aktualisiert.start", fAktualisiertStart));
        }

        if (fAktualisiertEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.aktualisiert.end", fAktualisiertEnd));
        }

        if (fDatumStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.datum.start", fDatumStart));
        }

        if (fDatumEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("f.datum.end", fDatumEnd));
        }

        if (fId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.id", fId));
        }

        if (fWahlperiode != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "f.wahlperiode", fWahlperiode));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyHeader", "ApiKeyQuery" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPersonListValidateBeforeCall(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<Integer> fId, List<Integer> fWahlperiode, String cursor, String format, final ApiCallback _callback) throws ApiException {
        return getPersonListCall(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fId, fWahlperiode, cursor, format, _callback);

    }

    /**
     * Liefert eine Liste von Personenstammdaten
     * 
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return PersonListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public PersonListResponse getPersonList(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<Integer> fId, List<Integer> fWahlperiode, String cursor, String format) throws ApiException {
        ApiResponse<PersonListResponse> localVarResp = getPersonListWithHttpInfo(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fId, fWahlperiode, cursor, format);
        return localVarResp.getData();
    }

    /**
     * Liefert eine Liste von Personenstammdaten
     * 
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @return ApiResponse&lt;PersonListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonListResponse> getPersonListWithHttpInfo(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<Integer> fId, List<Integer> fWahlperiode, String cursor, String format) throws ApiException {
        okhttp3.Call localVarCall = getPersonListValidateBeforeCall(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fId, fWahlperiode, cursor, format, null);
        Type localVarReturnType = new TypeToken<PersonListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Liefert eine Liste von Personenstammdaten (asynchronously)
     * 
     * @param fAktualisiertStart Frühestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fAktualisiertEnd Spätestes Aktualisierungsdatum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.  (optional)
     * @param fDatumStart Frühestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fDatumEnd Spätestes Datum der Entität  Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.  (optional)
     * @param fId ID der Entität  Kann wiederholt werden, um mehrere Entitäten zu selektieren.  (optional)
     * @param fWahlperiode Nummer der Wahlperiode  Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind. Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.  (optional)
     * @param cursor Position des Cursors zur Anfrage weiterer Entitäten  Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden. Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird. Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.  (optional)
     * @param format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML. (optional, default to json)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Personenstammdaten </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Syntaxfehler in einem der Anfrageparameter </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Ein gültiger API-Key ist für alle Anfragen erforderlich. Dieser kann entweder im HTTP Authorization Header oder als Anfrageparameter apikey gesendet werden. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPersonListAsync(OffsetDateTime fAktualisiertStart, OffsetDateTime fAktualisiertEnd, LocalDate fDatumStart, LocalDate fDatumEnd, List<Integer> fId, List<Integer> fWahlperiode, String cursor, String format, final ApiCallback<PersonListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPersonListValidateBeforeCall(fAktualisiertStart, fAktualisiertEnd, fDatumStart, fDatumEnd, fId, fWahlperiode, cursor, format, _callback);
        Type localVarReturnType = new TypeToken<PersonListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
